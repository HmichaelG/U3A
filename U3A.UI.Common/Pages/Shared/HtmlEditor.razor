@using System.Xml
@using System.Text
@using AngleSharp
@using AngleSharp.Dom
@using AngleSharp.Html
@using AngleSharp.Html.Dom
@using AngleSharp.Html.Parser
@using DevExpress.Blazor.Office
@using Ganss.Xss
@using DevExpress.AIIntegration.Blazor.HtmlEditor
@using DevExpress.Blazor
@using System.Text.RegularExpressions
@using System.Globalization



<MessageBox @ref=@messageBox />

<div class="html-edit-style">
<DxTabs @ref="@tabs" CssClass="w-100" >
    <DxTabPage Text="Editor">
        <DxHtmlEditor AllowSoftLineBreak="true"
                      TableResizeEnabled="true"
                      MediaResizeEnabled="false"
                      ValidationMessage="@errorText"
                      ValidationMessagePosition="HtmlEditorValidationMessagePosition.Top"
                      IsValid="@isValid"
                      BindMarkupMode="HtmlEditorBindMarkupMode.OnDelayedInput"
                      CustomizeToolbar="@OnCustomizeToolbar"
                      ReadOnly=@(Markup.Contains(editorComment))
                      @bind-Markup="@Markup"
                      @bind-Markup:after="@OnMarkupChanged"
                      Width="@Width" Height="@Height">
            <AdditionalItems>
                @if (!DisableAIExtensions)
                {
                    <SummarizeAIToolbarItem />
                    <ExplainAIToolbarItem />
                    <ProofreadAIToolbarItem />
                    <ExpandAIToolbarItem />
                    <ShortenAIToolbarItem />
                    <AskAssistantAIToolbarItem />
                    <ChangeStyleAIToolbarItem />
                    <ChangeToneAIToolbarItem />
                    <TranslateAIToolbarItem Languages="@("English, German, French, Chinese")" />
                }
            </AdditionalItems>
        </DxHtmlEditor>
        @if (Markup.Contains(editorComment))
        {
            <p class="text-fl-info" style="font-size: 0.6rem">
                <b>Read Only:</b> Markup  contains manual edits.
            </p>
        }
        else
        {
            <p style="font-size: 0.6rem">
            <div class="py-1">Always <DxButton Text="Sanitise" Click="@OnSanitise" /> after you copy / paste text.</div>
                <div>
                    <b>Hint:</b> <span class=key-style>Enter</span> = paragraph break;
                <span class=key-style>SHIFT</span> +
                <span class=key-style>Enter</span> = line break.
                </div>
            </p>
        }
    </DxTabPage>
    <DxTabPage Text="Code" Click="() => {Markup = HtmlHelpers.PrettyPrint(Markup);
                                            isCodeEditable=false;
                                            StateHasChanged();}">
        <DxMemo @bind-Text="@Markup" CssClass="w-100"
                @bind-Text:after=@OnEditorTextChanged
                Rows="20"
                ReadOnly="@(!isCodeEditable)" />
        <div class="d-flex gap-2 align-items-center">
        <DxButton Text="Edit" Click="OnEditClicked" CssClass="mt-1" />
        <span style="font-size: 0.6rem">Warning: Changes in the <b>Editor</b> will override <b>Code</b> changes.</span>
        </div>
        <div class="text-fl-danger">@errorText</div>
    </DxTabPage>
</DxTabs>
</div>

<style>
    .key-style {
        color: cadetblue;
        padding: 2px;
        border: 1px solid cadetblue;
        border-radius: 3px;
    }
    .html-edit-style {
            width: @Width;
    }
</style>
@code {

    [Parameter, EditorRequired]
    public required string Markup { get; set; }
    [Parameter]
    public EventCallback<string> MarkupChanged { get; set; }

    [Parameter]
    public string Width { get; set; } = "100%";
    [Parameter]
    public string? Height { get; set; }

    [Parameter]
    public bool DisableAIExtensions { get; set; }

    [Parameter]
    public bool HideFontMenu { get; set; }
    [Parameter]
    public bool HideTableMenu { get; set; }

    MessageBox? messageBox;
    DxTabs? tabs;
    bool isCodeEditable;
    static string errorText = "";
    bool isValid;

    const string editorComment = "<!-- markup contains manual edits -->";

    protected override Task OnInitializedAsync()
    {
        isValid = true;
        return base.OnInitializedAsync();
    }
    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        if (firstRender)
        {
            HtmlHelpers.PrettyPrint(Markup);
            tabs.ActiveTabIndex = Markup.Contains(editorComment) ? 1 : 0;
            StateHasChanged();
        }
    }
    async Task OnMarkupChanged()
    {
        ValidateImages();
        if (isValid && MarkupChanged.HasDelegate) 
        { 
            await MarkupChanged.InvokeAsync(Markup);
        }
    }

    async Task OnEditorTextChanged()
    {
        ValidateImages();
        if (isValid && MarkupChanged.HasDelegate)
        {
            if (!Markup.Contains(editorComment))
            {
                Markup += Environment.NewLine + editorComment;
            }
            await MarkupChanged.InvokeAsync(Markup);
        }
    }

    void ValidateImages()
    {
        var result = HtmlHelpers.ValidateImages(Markup);
        isValid = result.isValid;
        errorText = result.errorText;
    }

    void OnCustomizeToolbar(IToolbar toolbar )
    {
        if (HideFontMenu) toolbar.Groups.Remove(HtmlEditorToolbarGroupNames.Font);
        if (HideTableMenu) toolbar.Groups.Remove(HtmlEditorToolbarGroupNames.Table);
    }

    async Task OnEditClicked()
    {
        isCodeEditable = await messageBox!.ShowAsync("Advanced Only",
                       @"<p>Editing code requires knowledge of HTML programming.
                    Errors in code may render unpredictable results or system errors.</p>
                    Do you wish to continue?");
    }

    async Task OnSanitise()
    {
        Markup = HtmlHelpers.SanitizeHtml(Markup);
        await messageBox!.ShowAsync("Sanitise complete", "Your html code has been successfully sanitised.");
    }
}