@page "/Backup"

@using System.Data
@using System.IO
@using Microsoft.Data.SqlClient
@using ClosedXML.Excel
@using Serilog;
@using System.IO.Compression

@inject IJSRuntime js;
@inject IDbContextFactory<U3ADbContext> U3Adbfactory

<HeadContent>
    <script>
        window.downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
        }
    </script>
</HeadContent>

<div class="col col-md-6 h-75">
    <h3>Database Backup</h3>
    <p>
        This procedure will create a dump of your database and download it
        as an Excel spreadsheet workbook. It is intended as an aid to transition to another 
        software application rather than a formal backup. Formal backups are securely maintained within Microsoft's Azure datacenters.
    </p>
    <p>The spreadsheet downloaded contains your member's private information. Please treat with care and in accordance with privacy legislation in your state.</p>

    <DxButton Text="Do Backup" Click="@DoBackup" />
    <div class="m-4 card overflow-auto h-75">@(new MarkupString(state))</div>
</div>

@code {
    string state;

    private async Task DoBackup()
    {
        state = "";
        string connectionString;
        using (var db = await U3Adbfactory.CreateDbContextAsync())
        {
            // Get the connection string from the database context
            connectionString = db.TenantInfo.ConnectionString;
        }
        using (SqlConnection con = new SqlConnection(connectionString))
        {
            con.Open();

            // Get all table names
            DataTable tables = con.GetSchema("Tables", new string[] { null, null, null, "BASE TABLE" }); 
            DataView dv = tables.DefaultView;
            dv.Sort = "TABLE_NAME";

            using (XLWorkbook wb = new XLWorkbook())
            {
                foreach (DataRowView row in dv)
                {
                    string tableName = row["TABLE_NAME"].ToString();
                    state += $"Exporting table: {tableName}<br/>";
                    StateHasChanged();
                    using (SqlCommand cmd = new SqlCommand($"SELECT * FROM {tableName}", con))
                    {
                        DataTable dt = await FillDataTableAsync(cmd);
                        foreach (DataRow r in dt.Rows)
                        {
                            foreach (DataColumn c in dt.Columns)
                            {
                                if (r[c.ColumnName].ToString().Length >= Int16.MaxValue)
                                {
                                    r[c.ColumnName] = null;
                                }
                            }
                        }
                       var ws = wb.Worksheets.Add(dt, tableName);
                       ws.Columns().AdjustToContents();
                    }
                }

                // Save the workbook
                using (MemoryStream stream = new MemoryStream())
                {
                    wb.SaveAs(stream);
                    stream.Position = 0;
                    var fileName = "DatabaseExport.xlsx";
                    var fileStream = new DotNetStreamReference(new MemoryStream(CompressMemoryStream(stream,fileName)));
                    var zipName = "DatabaseExport.zip";
                    await js.InvokeVoidAsync("downloadFileFromStream", zipName, fileStream);
                    state += $"File {fileName} download successfully initiated.<br/>";
                }
            }
        }
        StateHasChanged();
    }

    public static byte[] CompressMemoryStream(MemoryStream inputStream, string fileNameInZip)
    {
        using (var zipStream = new MemoryStream())
        {
            using (var archive = new ZipArchive(zipStream, ZipArchiveMode.Create, true))
            {
                var zipEntry = archive.CreateEntry(fileNameInZip, CompressionLevel.Optimal);
                using (var entryStream = zipEntry.Open())
                {
                    inputStream.Position = 0; // Reset the position of the input stream
                    inputStream.CopyTo(entryStream);
                }
            }
            return zipStream.ToArray(); // Return the ZIP as a byte array
        }
    }
    public static async Task<DataTable> FillDataTableAsync(SqlCommand cmd)
    {
        DataTable dt = null;
        using (var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SequentialAccess))
        {

            DataTable schemaTable = await reader.GetSchemaTableAsync();
            dt = new DataTable();
            foreach (DataRow row in schemaTable.Rows)
                dt.Columns.Add(row.Field<string>("ColumnName"), row.Field<Type>("DataType"));


            while (await reader.ReadAsync())
            {
                DataRow dr = dt.Rows.Add();
                foreach (DataColumn col in dt.Columns)
                    dr[col.ColumnName] = reader[col.ColumnName];
            }
        }
        return dt;
    }
}


